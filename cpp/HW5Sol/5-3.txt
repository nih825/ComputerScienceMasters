If you have many threads and you have a lock in the doWork function, everytime that the function is called one of the threads would obtain the lock and all the other threads would be stuck waiting.  This would be inefficient and it would take a very long time for this method to complete and presumably the only portion of the code that needs to be thread safe is the incrementing of a global counter variable.
One way of fixing this is is to simply declare a counter variable as __thread and then each thread would get their own local variable version of a counter.  Then when the program is completed you could have one mutex that allows each thread to increment a global counter variable and then after every thread has updated this counter variable it is returned and is the correct number of times that doWork has been called. 